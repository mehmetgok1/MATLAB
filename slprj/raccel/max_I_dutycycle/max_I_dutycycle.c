#include "max_I_dutycycle.h"
#include "rtwtypes.h"
#include "mwmathutil.h"
#include "max_I_dutycycle_types.h"
#include "max_I_dutycycle_private.h"
#include "rt_logging_mmi.h"
#include "max_I_dutycycle_capi.h"
#include "max_I_dutycycle_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; extern ssExecutionInfo gblExecutionInfo ; RTWExtModeInfo *
gblRTWExtModeInfo = NULL ; void raccelForceExtModeShutdown ( boolean_T
extModeStartPktReceived ) { if ( ! extModeStartPktReceived ) { boolean_T
stopRequested = false ; rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 4 , &
stopRequested ) ; } rtExtModeShutdown ( 4 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 5 ; const char_T
* gbl_raccel_Version = "24.2 (R2024b) 21-Jun-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
B rtB ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS = &
model_S ; void MdlInitialize ( void ) { rtDW . mminpo5024 = rtP .
UnitDelay_InitialCondition ; { int32_T i , j ; real_T * As = ( real_T * )
rtDW . dytl2oqz3i . AS ; real_T * Bs = ( real_T * ) rtDW . dytl2oqz3i . BS ;
real_T * Cs = ( real_T * ) rtDW . dytl2oqz3i . CS ; real_T * Ds = ( real_T *
) rtDW . dytl2oqz3i . DS ; real_T * X0 = ( real_T * ) & rtDW . djksolzyus [ 0
] ; for ( i = 0 ; i < 4 ; i ++ ) { X0 [ i ] = ( rtP . StateSpace_X0_param [ i
] ) ; } for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) As [ i *
4 + j ] = ( rtP . StateSpace_AS_param [ i + j * 4 ] ) ; for ( j = 0 ; j < 9 ;
j ++ ) Bs [ i * 9 + j ] = ( rtP . StateSpace_BS_param [ i + j * 4 ] ) ; } for
( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) Cs [ i * 4 + j ] = ( rtP
. StateSpace_CS_param [ i + j * 8 ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { for
( j = 0 ; j < 9 ; j ++ ) Ds [ i * 9 + j ] = ( rtP . StateSpace_DS_param [ i +
j * 8 ] ) ; } { int_T * switch_status = ( int_T * ) rtDW . dytl2oqz3i .
SWITCH_STATUS ; int_T * gState = ( int_T * ) rtDW . dytl2oqz3i . G_STATE ;
real_T * yswitch = ( real_T * ) rtDW . dytl2oqz3i . Y_SWITCH ; int_T *
switchTypes = ( int_T * ) rtDW . dytl2oqz3i . SWITCH_TYPES ; int_T * idxOutSw
= ( int_T * ) rtDW . dytl2oqz3i . IDX_OUT_SW ; int_T * switch_status_init = ( int_T * ) rtDW . dytl2oqz3i . SWITCH_STATUS_INIT ; switch_status [ 0 ] = 0 ; switch_status_init [ 0 ] = 0 ; gState [ 0 ] = ( int_T ) 0.0 ; yswitch [ 0 ] = 1 / 0.1 ; switchTypes [ 0 ] = ( int_T ) 1.0 ; idxOutSw [ 0 ] = ( ( int_T ) 0.0 ) - 1 ; switch_status [ 1 ] = 0 ; switch_status_init [ 1 ] = 0 ; gState [ 1 ] = ( int_T ) 0.0 ; yswitch [ 1 ] = 1 / 0.001 ; switchTypes [ 1 ] = ( int_T ) 3.0 ; idxOutSw [ 1 ] = ( ( int_T ) 0.0 ) - 1 ; switch_status [ 2 ] = 0 ; switch_status_init [ 2 ] = 0 ; gState [ 2 ] = ( int_T ) 0.0 ; yswitch [ 2 ] = 1 / 0.001 ; switchTypes [ 2 ] = ( int_T ) 3.0 ; idxOutSw [ 2 ] = ( ( int_T ) 0.0 ) - 1 ; switch_status [ 3 ] = 0 ; switch_status_init [ 3 ] = 0 ; gState [ 3 ] = ( int_T ) 0.0 ; yswitch [ 3 ] = 1 / 0.01 ; switchTypes [ 3 ] = ( int_T ) 3.0 ; idxOutSw [ 3 ] = ( ( int_T ) 0.0 ) - 1 ; } } rtDW . op0zj40xk4 = rtP . Output_InitialCondition ; rtDW . fom2xtbnuw = ssGetTaskTime ( rtS , 0 ) ; rtDW . kb4hx0puig = true ; rtDW . jhvnjdl2p3 = true ; rtDW . lr1ooejihk = ssGetTaskTime ( rtS , 0 ) ; rtDW . lqm1dvfvxs = ( rtMinusInf ) ; rtDW . nolnqwxnel = 0UL ; rtDW . p4waz02w00 = true ; rtDW . hmnjp3gdve = true ; } void MdlEnable ( void ) { _ssSetSampleHit ( rtS , 3 , 1 ) ; _ssSetTaskTime ( rtS , 3 , ssGetT ( rtS ) ) ; _ssSetVarNextHitTime ( rtS , 0 , ssGetT ( rtS ) ) ; ; rtDW . kb4hx0puig = true ; rtDW . jhvnjdl2p3 = true ; rtDW . lr1ooejihk = ssGetTaskTime ( rtS , 0 ) ; rtDW . lqm1dvfvxs = ( rtMinusInf ) ; rtDW . nolnqwxnel = 0UL ; } void MdlStart ( void ) { { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { } } { rtDW . dytl2oqz3i . AS = ( real_T * ) calloc ( 4 * 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . BS = ( real_T * ) calloc ( 4 * 9 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . CS = ( real_T * ) calloc ( 8 * 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . DS = ( real_T * ) calloc ( 8 * 9 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . DX_COL = ( real_T * ) calloc ( 8 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . TMP2 = ( real_T * ) calloc ( 9 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . BD_COL = ( real_T * ) calloc ( 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . TMP1 = ( real_T * ) calloc ( 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . XTMP = ( real_T * ) calloc ( 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . SWITCH_STATUS = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . SW_CHG = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . G_STATE = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . Y_SWITCH = ( real_T * ) calloc ( 4 , sizeof ( real_T ) ) ; rtDW . dytl2oqz3i . SWITCH_TYPES = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . IDX_OUT_SW = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . SWITCH_STATUS_INIT = ( int_T * ) calloc ( 4 , sizeof ( int_T ) ) ; rtDW . dytl2oqz3i . USWLAST = ( real_T * ) calloc ( 4 , sizeof ( real_T ) ) ; } MdlInitialize ( ) ; MdlEnable ( ) ; } void MdlOutputs ( int_T tid ) { real_T in54homnsm ; int32_T tmp ; uint8_T jcakw23qih ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . mzpip0bwqa = rtDW . mminpo5024 ; { real_T accum ; int_T * switch_status = ( int_T * ) rtDW . dytl2oqz3i . SWITCH_STATUS ; int_T * switch_status_init = ( int_T * ) rtDW . dytl2oqz3i . SWITCH_STATUS_INIT ; int_T * SwitchChange = ( int_T * ) rtDW . dytl2oqz3i . SW_CHG ; int_T * gState = ( int_T * ) rtDW . dytl2oqz3i . G_STATE ; real_T * yswitch = ( real_T * ) rtDW . dytl2oqz3i . Y_SWITCH ; int_T * switchTypes = ( int_T * ) rtDW . dytl2oqz3i . SWITCH_TYPES ; int_T * idxOutSw = ( int_T * ) rtDW . dytl2oqz3i . IDX_OUT_SW ; real_T * DxCol = ( real_T * ) rtDW . dytl2oqz3i . DX_COL ; real_T * tmp2 = ( real_T * ) rtDW . dytl2oqz3i . TMP2 ; real_T * BDcol = ( real_T * ) rtDW . dytl2oqz3i . BD_COL ; real_T * tmp1 = ( real_T * ) rtDW . dytl2oqz3i . TMP1 ; real_T * uswlast = ( real_T * ) rtDW . dytl2oqz3i . USWLAST ; int_T newState ; int_T swChanged = 0 ; int loopsToDo = 20 ; real_T temp ; memcpy ( switch_status_init , switch_status , 4 * sizeof ( int_T ) ) ; memcpy ( uswlast , & rtB . ectzrserex [ 0 ] , 4 * sizeof ( real_T ) ) ; do { if ( loopsToDo == 1 ) { swChanged = 0 ; { int_T i1 ; for ( i1 = 0 ; i1 < 4 ; i1 ++ ) { swChanged = ( ( SwitchChange [ i1 ] = switch_status_init [ i1 ] - switch_status [ i1 ] ) != 0 ) ? 1 : swChanged ; switch_status [ i1 ] = switch_status_init [ i1 ] ; } } } else { real_T * Cs = ( real_T * ) rtDW . dytl2oqz3i . CS ; real_T * Ds = ( real_T * ) rtDW . dytl2oqz3i . DS ; { int_T i1 ; real_T * y0 = & rtB . ectzrserex [ 0 ] ; for ( i1 = 0 ; i1 < 8 ; i1 ++ ) { accum = 0.0 ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Ds ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Ds ++ ) * rtB . mzpip0bwqa ; accum += * ( Ds ++ ) * rtB . fbsyboay3c ; accum += * ( Ds ++ ) * rtP . eee_Value ; accum += * ( Ds ++ ) * rtP . eee_Value_mymnzp31cs ; y0 [ i1 ] = accum ; } } swChanged = 0 ; newState = gState [ 0 ] > 0 ? 1 : 0 ; swChanged = ( ( SwitchChange [ 0 ] = newState - switch_status [ 0 ] ) != 0 ) ? 1 : swChanged ; switch_status [ 0 ] = newState ; newState = rtB . ectzrserex [ 1 ] > 0.0 ? 1 : ( ( rtB . ectzrserex [ 1 ] < 0.0 ) ? 0 : switch_status [ 1 ] ) ; swChanged = ( ( SwitchChange [ 1 ] = newState - switch_status [ 1 ] ) != 0 ) ? 1 : swChanged ; switch_status [ 1 ] = newState ; newState = rtB . ectzrserex [ 2 ] > 0.0 ? 1 : ( ( rtB . ectzrserex [ 2 ] < 0.0 ) ? 0 : switch_status [ 2 ] ) ; swChanged = ( ( SwitchChange [ 2 ] = newState - switch_status [ 2 ] ) != 0 ) ? 1 : swChanged ; switch_status [ 2 ] = newState ; newState = rtB . ectzrserex [ 3 ] > 0.0 ? 1 : ( ( rtB . ectzrserex [ 3 ] < 0.0 ) ? 0 : switch_status [ 3 ] ) ; swChanged = ( ( SwitchChange [ 3 ] = newState - switch_status [ 3 ] ) != 0 ) ? 1 : swChanged ; switch_status [ 3 ] = newState ; } if ( swChanged ) { real_T * As = ( real_T * ) rtDW . dytl2oqz3i . AS ; real_T * Cs = ( real_T * ) rtDW . dytl2oqz3i . CS ; real_T * Bs = ( real_T * ) rtDW . dytl2oqz3i . BS ; real_T * Ds = ( real_T * ) rtDW . dytl2oqz3i . DS ; real_T a1 ; { int_T i1 ; for ( i1 = 0 ; i1 < 4 ; i1 ++ ) { if ( SwitchChange [ i1 ] != 0 ) { a1 = yswitch [ i1 ] * SwitchChange [ i1 ] ; temp = 1 / ( 1 - Ds [ i1 * 10 ] * a1 ) ; { int_T i2 ; for ( i2 = 0 ; i2 < 8 ; i2 ++ ) { DxCol [ i2 ] = Ds [ i2 * 9 + i1 ] * temp * a1 ; } } DxCol [ i1 ] = temp ; BDcol [ 0 ] = Bs [ 0 + i1 ] * a1 ; BDcol [ 1 ] = Bs [ 9 + i1 ] * a1 ; BDcol [ 2 ] = Bs [ 18 + i1 ] * a1 ; BDcol [ 3 ] = Bs [ 27 + i1 ] * a1 ; memcpy ( tmp1 , & Cs [ i1 * 4 ] , 4 * sizeof ( real_T ) ) ; memset ( & Cs [ i1 * 4 ] , '\0' , 4 * sizeof ( real_T ) ) ; memcpy ( tmp2 , & Ds [ i1 * 9 ] , 9 * sizeof ( real_T ) ) ; memset ( & Ds [ i1 * 9 ] , '\0' , 9 * sizeof ( real_T ) ) ; { int_T i2 ; for ( i2 = 0 ; i2 < 8 ; i2 ++ ) { a1 = DxCol [ i2 ] ; Cs [ i2 * 4 + 0 ] += a1 * tmp1 [ 0 ] ; Cs [ i2 * 4 + 1 ] += a1 * tmp1 [ 1 ] ; Cs [ i2 * 4 + 2 ] += a1 * tmp1 [ 2 ] ; Cs [ i2 * 4 + 3 ] += a1 * tmp1 [ 3 ] ; { int_T i3 ; for ( i3 = 0 ; i3 < 9 ; i3 ++ ) { Ds [ i2 * 9 + i3 ] += a1 * tmp2 [ i3 ] ; } } } } a1 = BDcol [ 0 ] ; As [ 0 + 0 ] += a1 * Cs [ i1 * 4 + 0 ] ; As [ 0 + 1 ] += a1 * Cs [ i1 * 4 + 1 ] ; As [ 0 + 2 ] += a1 * Cs [ i1 * 4 + 2 ] ; As [ 0 + 3 ] += a1 * Cs [ i1 * 4 + 3 ] ; { int_T i2 ; for ( i2 = 0 ; i2 < 9 ; i2 ++ ) { Bs [ 0 + i2 ] += a1 * Ds [ i1 * 9 + i2 ] ; } } a1 = BDcol [ 1 ] ; As [ 4 + 0 ] += a1 * Cs [ i1 * 4 + 0 ] ; As [ 4 + 1 ] += a1 * Cs [ i1 * 4 + 1 ] ; As [ 4 + 2 ] += a1 * Cs [ i1 * 4 + 2 ] ; As [ 4 + 3 ] += a1 * Cs [ i1 * 4 + 3 ] ; { int_T i2 ; for ( i2 = 0 ; i2 < 9 ; i2 ++ ) { Bs [ 9 + i2 ] += a1 * Ds [ i1 * 9 + i2 ] ; } } a1 = BDcol [ 2 ] ; As [ 8 + 0 ] += a1 * Cs [ i1 * 4 + 0 ] ; As [ 8 + 1 ] += a1 * Cs [ i1 * 4 + 1 ] ; As [ 8 + 2 ] += a1 * Cs [ i1 * 4 + 2 ] ; As [ 8 + 3 ] += a1 * Cs [ i1 * 4 + 3 ] ; { int_T i2 ; for ( i2 = 0 ; i2 < 9 ; i2 ++ ) { Bs [ 18 + i2 ] += a1 * Ds [ i1 * 9 + i2 ] ; } } a1 = BDcol [ 3 ] ; As [ 12 + 0 ] += a1 * Cs [ i1 * 4 + 0 ] ; As [ 12 + 1 ] += a1 * Cs [ i1 * 4 + 1 ] ; As [ 12 + 2 ] += a1 * Cs [ i1 * 4 + 2 ] ; As [ 12 + 3 ] += a1 * Cs [ i1 * 4 + 3 ] ; { int_T i2 ; for ( i2 = 0 ; i2 < 9 ; i2 ++ ) { Bs [ 27 + i2 ] += a1 * Ds [ i1 * 9 + i2 ] ; } } } } } } } while ( swChanged > 0 && -- loopsToDo > 0 ) ; if ( loopsToDo == 0 ) { real_T * Cs = ( real_T * ) rtDW . dytl2oqz3i . CS ; real_T * Ds = ( real_T * ) rtDW . dytl2oqz3i . DS ; { int_T i1 ; real_T * y0 = & rtB . ectzrserex [ 0 ] ; for ( i1 = 0 ; i1 < 8 ; i1 ++ ) { accum = 0.0 ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( Cs ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Ds ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Ds ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Ds ++ ) * rtB . mzpip0bwqa ; accum += * ( Ds ++ ) * rtB . fbsyboay3c ; accum += * ( Ds ++ ) * rtP . eee_Value ; accum += * ( Ds ++ ) * rtP . eee_Value_mymnzp31cs ; y0 [ i1 ] = accum ; } } } rtB . bvtsrcs5qf [ 0 ] = ( real_T ) switch_status [ 0 ] ; rtB . bvtsrcs5qf [ 1 ] = ( real_T ) switch_status [ 1 ] ; rtB . bvtsrcs5qf [ 2 ] = ( real_T ) switch_status [ 2 ] ; rtB . bvtsrcs5qf [ 3 ] = ( real_T ) switch_status [ 3 ] ; } rtB . ai1jmox3el = rtP . donotdeletethisgain_Gain * rtB . ectzrserex [ 4 ] ; rtB . jn3yy0pplo = rtP . donotdeletethisgain_Gain_d4jhy2psxl * rtB . ectzrserex [ 7 ] ; rtB . fjuvc31hed = rtB . ai1jmox3el * rtB . jn3yy0pplo ; rtB . mwyverf4rq = rtP . donotdeletethisgain_Gain_mp54r4l1oy * rtB . ectzrserex [ 6 ] ; } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { jcakw23qih = rtDW . op0zj40xk4 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtB . gxp1pfce0w = rtP . RepeatingSequenceStair_OutValues [ rtDW . op0zj40xk4 ] ; } else { if ( rtDW . op0zj40xk4 > 15 ) { tmp = 15 ; } else { tmp = rtDW . op0zj40xk4 ; } rtB . gxp1pfce0w = rtP . RepeatingSequenceStair_OutValues [ tmp ] ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . m5egozilov = rtP . donotdeletethisgain_Gain_fo1neunnau * rtB . ectzrserex [ 5 ] ; rtB . iitgowgawd = rtB . fjuvc31hed / rtP . Constant1_Value * rtP . Constant3_Value ; rtB . ate1zx5an4 = rtB . mwyverf4rq * rtB . m5egozilov / rtB . fjuvc31hed * rtP . Constant4_Value ; } if ( ssIsSampleHit ( rtS , 3 , 0 ) ) { if ( ( rtB . gxp1pfce0w * rtP . PWM_Period + ssGetTaskTime ( rtS , 0 ) <= ssGetTaskTime ( rtS , 0 ) + 2.8421709430404007E-14 ) && rtDW . jhvnjdl2p3 ) { rtB . mijk53iy5v = 0.0 ; rtDW . kb4hx0puig = false ; } else { rtB . mijk53iy5v = rtDW . kb4hx0puig ; } } if ( ssIsSampleHit ( rtS , 0 , 0 ) ) { } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { in54homnsm = rtB . jn3yy0pplo * rtP . Rs_array_Value + rtB . ai1jmox3el ; rtB . ke2w1amc5d = ( ( muDoubleScalarExp ( 1.0 / rtB . fkvi0lsqg3 * in54homnsm ) - rtP . one_Value ) * rtB . cyqfylhq5l + in54homnsm / rtP . Rsh_array_Value * rtB . k1o0wmy3qb ) - in54homnsm / rtP . Rsh_array_5Sref_Value ; } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { jcakw23qih += rtP . FixPtConstant_Value ; if ( jcakw23qih > rtP . WrapToZero_Threshold ) { rtB . lqm5fmnuma = rtP . Constant_Value_dkcolwy3k2 ; } else { rtB . lqm5fmnuma = jcakw23qih ; } } UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID4 ( int_T tid ) { real_T ge3uchhneh ; real_T jhcg0hszeb ; rtB . k1o0wmy3qb = rtP . uSref_Gain * rtP . Constant_Value ; jhcg0hszeb = rtP . Constant2_Value + rtP . u_K_Value ; rtB . fbsyboay3c = ( ( jhcg0hszeb - rtP . Tref_K_Value ) * rtP . alpha_Isc_Gain + rtP . IL_module_Value ) * rtP . PVArray_Npar * rtB . k1o0wmy3qb ; ge3uchhneh = jhcg0hszeb / rtP . Tref_K2_Value ; rtB . cyqfylhq5l = muDoubleScalarExp ( rtP . EgRef_Value - ( ( jhcg0hszeb - rtP . Tref_K1_Value ) * rtP . dEgdT_Gain + rtP . one1_Value ) * rtP . EgRef_Gain / ( rtP . k1_Gain * jhcg0hszeb ) ) * ( rtP . I0_array_Gain * muDoubleScalarPower ( ge3uchhneh , 3.0 ) ) ; rtB . fkvi0lsqg3 = rtP . VT_ref_array_Gain * ge3uchhneh ; UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { real_T dc ; SimStruct * S ; void * diag ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . mminpo5024 = rtB . ke2w1amc5d ; { const real_T * As = ( real_T * ) rtDW . dytl2oqz3i . AS ; const real_T * Bs = ( real_T * ) rtDW . dytl2oqz3i . BS ; real_T * xtmp = ( real_T * ) rtDW . dytl2oqz3i . XTMP ; real_T accum ; accum = 0.0 ; accum += * ( As ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Bs ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Bs ++ ) * rtB . mzpip0bwqa ; accum += * ( Bs ++ ) * rtB . fbsyboay3c ; accum += * ( Bs ++ ) * rtP . eee_Value ; accum += * ( Bs ++ ) * rtP . eee_Value_mymnzp31cs ; xtmp [ 0 ] = accum ; accum = 0.0 ; accum += * ( As ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Bs ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Bs ++ ) * rtB . mzpip0bwqa ; accum += * ( Bs ++ ) * rtB . fbsyboay3c ; accum += * ( Bs ++ ) * rtP . eee_Value ; accum += * ( Bs ++ ) * rtP . eee_Value_mymnzp31cs ; xtmp [ 1 ] = accum ; accum = 0.0 ; accum += * ( As ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Bs ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Bs ++ ) * rtB . mzpip0bwqa ; accum += * ( Bs ++ ) * rtB . fbsyboay3c ; accum += * ( Bs ++ ) * rtP . eee_Value ; accum += * ( Bs ++ ) * rtP . eee_Value_mymnzp31cs ; xtmp [ 2 ] = accum ; accum = 0.0 ; accum += * ( As ++ ) * rtDW . djksolzyus [ 0 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 1 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 2 ] ; accum += * ( As ++ ) * rtDW . djksolzyus [ 3 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 0 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 1 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 2 ] ; accum += * ( Bs ++ ) * rtP . SwitchCurrents_Value [ 3 ] ; accum += * ( Bs ++ ) * rtP . DCVoltageSource_Amplitude ; accum += * ( Bs ++ ) * rtB . mzpip0bwqa ; accum += * ( Bs ++ ) * rtB . fbsyboay3c ; accum += * ( Bs ++ ) * rtP . eee_Value ; accum += * ( Bs ++ ) * rtP . eee_Value_mymnzp31cs ; xtmp [ 3 ] = accum ; rtDW . djksolzyus [ 0 ] = xtmp [ 0 ] ; rtDW . djksolzyus [ 1 ] = xtmp [ 1 ] ; rtDW . djksolzyus [ 2 ] = xtmp [ 2 ] ; rtDW . djksolzyus [ 3 ] = xtmp [ 3 ] ; { int_T * gState = ( int_T * ) rtDW . dytl2oqz3i . G_STATE ; * ( gState ++ ) = ( int_T ) rtB . mijk53iy5v ; * ( gState ++ ) = ( int_T ) 0.0 ; * ( gState ++ ) = ( int_T ) 0.0 ; * ( gState ++ ) = ( int_T ) 0.0 ; } } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . op0zj40xk4 = rtB . lqm5fmnuma ; } if ( ssIsSampleHit ( rtS , 3 , 0 ) ) { if ( muDoubleScalarIsNaN ( rtB . gxp1pfce0w ) || ( ( rtB . gxp1pfce0w == ( rtInf ) ) || ( rtB . gxp1pfce0w == ( rtMinusInf ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputDutyCycleForVPG" , 3 , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" , 2 , rtB . gxp1pfce0w , 2 , ssGetTaskTime ( rtS , 3 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( rtDW . kb4hx0puig ) { dc = rtB . gxp1pfce0w ; if ( ( rtP . PWM_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM_Period ) || ( ( rtP . PWM_Period == ( rtInf ) ) || ( rtP . PWM_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 0 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc * rtP . PWM_Period + ssGetTaskTime ( rtS , 0 ) <= 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 0 ) + ssGetTaskTime ( rtS , 0 ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvPulseWidthForVPG" , 5 , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" , 2 , rtB . gxp1pfce0w , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 0 ) , 2 , 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 0 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( dc > 1.0 ) { dc = 1.0 ; if ( rtDW . p4waz02w00 ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleGreaterThanOne" , 3 , 2 , ssGetTaskTime ( rtS , 0 ) , 2 , rtB . gxp1pfce0w , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . p4waz02w00 = false ; } } else if ( 1.0 - rtB . gxp1pfce0w < 2.8421709430404007E-14 ) { dc = 1.0 ; } if ( ( rtDW . lqm1dvfvxs > 0.0 ) && ( rtDW . lqm1dvfvxs == rtP . PWM_Period ) ) { rtDW . nolnqwxnel ++ ; } else { rtDW . nolnqwxnel = 1UL ; rtDW . lqm1dvfvxs = rtP . PWM_Period ; rtDW . lr1ooejihk = ssGetTaskTime ( rtS , 0 ) ; } rtDW . fom2xtbnuw = rtDW . lqm1dvfvxs * ( real_T ) rtDW . nolnqwxnel + rtDW . lr1ooejihk ; if ( rtDW . fom2xtbnuw - ( dc * rtP . PWM_Period + ssGetTaskTime ( rtS , 0 ) ) > rtDW . fom2xtbnuw * 2.8421709430404007E-14 ) { _ssSetVarNextHitTime ( rtS , 0 , ssGetTaskTime ( rtS , 0 ) + dc * rtP . PWM_Period ) ; rtDW . kb4hx0puig = false ; rtDW . jhvnjdl2p3 = false ; } else { _ssSetVarNextHitTime ( rtS , 0 , rtDW . fom2xtbnuw ) ; rtDW . kb4hx0puig = true ; rtDW . jhvnjdl2p3 = true ; } } else { if ( rtDW . jhvnjdl2p3 ) { if ( ( rtP . PWM_Period <= 0.0 ) || ( muDoubleScalarIsNaN ( rtP . PWM_Period ) || ( ( rtP . PWM_Period == ( rtInf ) ) || ( rtP . PWM_Period == ( rtMinusInf ) ) ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:InvInputPeriodForVPG" , 3 , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" , 2 , rtP . PWM_Period , 2 , ssGetTaskTime ( rtS , 0 ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; } if ( ( rtB . gxp1pfce0w < 0.0 ) && rtDW . hmnjp3gdve ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:warnDutyCycleLessThanZero" , 3 , 2 , ssGetTaskTime ( rtS , 0 ) , 2 , rtB . gxp1pfce0w , 3 , "max_I_dutycycle/PWM/Variable Pulse Generator" ) ; rt_ssReportDiagnosticAsWarning ( S , diag ) ; rtDW . hmnjp3gdve = false ; } if ( ( rtDW . lqm1dvfvxs > 0.0 ) && ( rtDW . lqm1dvfvxs == rtP . PWM_Period ) ) { rtDW . nolnqwxnel ++ ; } else { rtDW . nolnqwxnel = 1UL ; rtDW . lqm1dvfvxs = rtP . PWM_Period ; rtDW . lr1ooejihk = ssGetTaskTime ( rtS , 0 ) ; } _ssSetVarNextHitTime ( rtS , 0 , ssGetTaskTime ( rtS , 0 ) + rtP . PWM_Period ) ; } else if ( rtDW . fom2xtbnuw > 2.8421709430404007E-14 * ssGetTaskTime ( rtS , 0 ) + ssGetTaskTime ( rtS , 0 ) ) { _ssSetVarNextHitTime ( rtS , 0 , rtDW . fom2xtbnuw ) ; } rtDW . kb4hx0puig = true ; rtDW . jhvnjdl2p3 = true ; } } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID4 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlTerminate ( void ) { { free ( rtDW . dytl2oqz3i . AS ) ; free ( rtDW . dytl2oqz3i . BS ) ; free ( rtDW . dytl2oqz3i . CS ) ; free ( rtDW . dytl2oqz3i . DS ) ; free ( rtDW . dytl2oqz3i . DX_COL ) ; free ( rtDW . dytl2oqz3i . TMP2 ) ; free ( rtDW . dytl2oqz3i . BD_COL ) ; free ( rtDW . dytl2oqz3i . TMP1 ) ; free ( rtDW . dytl2oqz3i . XTMP ) ; free ( rtDW . dytl2oqz3i . G_STATE ) ; free ( rtDW . dytl2oqz3i . SWITCH_STATUS ) ; free ( rtDW . dytl2oqz3i . SW_CHG ) ; free ( rtDW . dytl2oqz3i . SWITCH_STATUS_INIT ) ; } } static void mr_max_I_dutycycle_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_max_I_dutycycle_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_max_I_dutycycle_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_max_I_dutycycle_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_max_I_dutycycle_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_max_I_dutycycle_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_max_I_dutycycle_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_max_I_dutycycle_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_max_I_dutycycle_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_max_I_dutycycle_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_max_I_dutycycle_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_max_I_dutycycle_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_max_I_dutycycle_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_max_I_dutycycle_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_max_I_dutycycle_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_max_I_dutycycle_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_max_I_dutycycle_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 12 ] = { "rtDW.mminpo5024" , "rtDW.djksolzyus" , "rtDW.fom2xtbnuw" , "rtDW.lr1ooejihk" , "rtDW.lqm1dvfvxs" , "rtDW.nolnqwxnel" , "rtDW.b4wyf5afdw" , "rtDW.op0zj40xk4" , "rtDW.kb4hx0puig" , "rtDW.jhvnjdl2p3" , "rtDW.p4waz02w00" , "rtDW.hmnjp3gdve" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 12 , rtdwDataFieldNames ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . mminpo5024 ) , sizeof ( rtDW . mminpo5024 ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . djksolzyus ) , sizeof ( rtDW . djksolzyus ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . fom2xtbnuw ) , sizeof ( rtDW . fom2xtbnuw ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . lr1ooejihk ) , sizeof ( rtDW . lr1ooejihk ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . lqm1dvfvxs ) , sizeof ( rtDW . lqm1dvfvxs ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . nolnqwxnel ) , sizeof ( rtDW . nolnqwxnel ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . b4wyf5afdw ) , sizeof ( rtDW . b4wyf5afdw ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . op0zj40xk4 ) , sizeof ( rtDW . op0zj40xk4 ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . kb4hx0puig ) , sizeof ( rtDW . kb4hx0puig ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . jhvnjdl2p3 ) , sizeof ( rtDW . jhvnjdl2p3 ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . p4waz02w00 ) , sizeof ( rtDW . p4waz02w00 ) ) ; mr_max_I_dutycycle_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . hmnjp3gdve ) , sizeof ( rtDW . hmnjp3gdve ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_max_I_dutycycle_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . mminpo5024 ) , rtdwData , 0 , 0 , sizeof ( rtDW . mminpo5024 ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . djksolzyus ) , rtdwData , 0 , 1 , sizeof ( rtDW . djksolzyus ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . fom2xtbnuw ) , rtdwData , 0 , 2 , sizeof ( rtDW . fom2xtbnuw ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . lr1ooejihk ) , rtdwData , 0 , 3 , sizeof ( rtDW . lr1ooejihk ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . lqm1dvfvxs ) , rtdwData , 0 , 4 , sizeof ( rtDW . lqm1dvfvxs ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . nolnqwxnel ) , rtdwData , 0 , 5 , sizeof ( rtDW . nolnqwxnel ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . b4wyf5afdw ) , rtdwData , 0 , 6 , sizeof ( rtDW . b4wyf5afdw ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . op0zj40xk4 ) , rtdwData , 0 , 7 , sizeof ( rtDW . op0zj40xk4 ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . kb4hx0puig ) , rtdwData , 0 , 8 , sizeof ( rtDW . kb4hx0puig ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . jhvnjdl2p3 ) , rtdwData , 0 , 9 , sizeof ( rtDW . jhvnjdl2p3 ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . p4waz02w00 ) , rtdwData , 0 , 10 , sizeof ( rtDW . p4waz02w00 ) ) ; mr_max_I_dutycycle_restoreDataFromMxArray ( ( void * ) & ( rtDW . hmnjp3gdve ) , rtdwData , 0 , 11 , sizeof ( rtDW . hmnjp3gdve ) ) ; } } mxArray * mr_max_I_dutycycle_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 4 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 4 ] = { "S-Function" , "Scope" , "Scope" , "S-Function" , } ; static const char_T * blockPath [ 4 ] = { "max_I_dutycycle/powergui/EquivalentModel1/State-Space" , "max_I_dutycycle/Scope" , "max_I_dutycycle/Scope2" , "max_I_dutycycle/powergui/EquivalentModel1/State-Space" , } ; static const int reason [ 4 ] = { 0 , 0 , 0 , 2 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 4 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 4 ) ; ssSetNumBlocks ( rtS , 123 ) ; ssSetNumBlockIO ( rtS , 18 ) ; ssSetNumBlockParams ( rtS , 217 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 1.0E-9 ) ; ssSetSampleTime ( rtS , 2 , 0.005 ) ; ssSetSampleTime ( rtS , 3 , - 2.0 ) ; ssSetOffsetTime ( rtS , 0 , 1.0 ) ; ssSetOffsetTime ( rtS , 1 , 0.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; ssSetOffsetTime ( rtS , 3 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 271480689U ) ; ssSetChecksumVal ( rtS , 1 , 3186349354U ) ; ssSetChecksumVal ( rtS , 2 , 4153339654U ) ; ssSetChecksumVal ( rtS , 3 , 2395623712U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 24 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } max_I_dutycycle_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "max_I_dutycycle" ) ; ssSetPath ( rtS , "max_I_dutycycle" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 0.075 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 4 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 4 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_UINT8 } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "DSTATE" , "DSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "max_I_dutycycle/PV Array/Diode Rsh/Unit Delay" , "max_I_dutycycle/powergui/EquivalentModel1/State-Space" , "max_I_dutycycle/Repeating\nSequence\nStair/LimitedCounter/Output" } ; static const char_T * rt_LoggedStateNames [ ] = { "DSTATE" , "DSTATE" , "DSTATE" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_UINT8 , SS_UINT8 , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 10 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 3 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 3 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtDW . mminpo5024 ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) rtDW . djksolzyus ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtDW . op0zj40xk4 ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static ssSolverInfo slvrInfo ; ssSetStepSize ( rtS , 1.0E-9 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 1.0E-9 ) ; ssSetSolverMaxOrder ( rtS , - 1 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , ( NULL ) ) ; ssSetNumOutputTimes ( rtS , 0 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 0 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 0 ) ; ssSetNonContDerivSigInfos ( rtS , ( NULL ) ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "VariableStepDiscrete" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; } ssSetChecksumVal ( rtS , 0 , 271480689U ) ; ssSetChecksumVal ( rtS , 1 , 3186349354U ) ; ssSetChecksumVal ( rtS , 2 , 4153339654U ) ; ssSetChecksumVal ( rtS , 3 , 2395623712U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 1 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_max_I_dutycycle_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_max_I_dutycycle_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_max_I_dutycycle_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID4 ( tid ) ; }
