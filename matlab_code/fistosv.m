function fistosv(fis_filename, output_sv)
    % Load FIS file
    fis = readfis(fis_filename);
    
    % Generate SystemVerilog code
    fid = fopen(output_sv, 'w');
    
    fprintf(fid, '// Auto-generated Fuzzy Controller from %s\n', fis_filename);
    fprintf(fid, '// Generated by MATLAB FIS to SV converter\n\n');
    
    fprintf(fid, 'module fuzzy_controller (\n');
    fprintf(fid, '    input  real %s,\n', fis.input(1).name);
    for i = 2:length(fis.input)
        fprintf(fid, '    input  real %s,\n', fis.input(i).name);
    end
    fprintf(fid, '    output real %s,\n', fis.output(1).name);
    fprintf(fid, '    input  clk\n');
    fprintf(fid, ');\n\n');
    
    % Write membership functions
    for i = 1:length(fis.input)
        fprintf(fid, '    // %s membership functions\n', fis.input(i).name);
        for j = 1:length(fis.input(i).mf)
            mf = fis.input(i).mf(j);
            fprintf(fid, '    function real %s_%s;\n', fis.input(i).name, mf.name);
            fprintf(fid, '        input real x;\n');
            
            if strcmp(mf.type, 'trimf')
                fprintf(fid, '        %s_%s = trimf(x, %f, %f, %f);\n', ...
                    fis.input(i).name, mf.name, mf.params(1), mf.params(2), mf.params(3));
            elseif strcmp(mf.type, 'trapmf')
                fprintf(fid, '        %s_%s = trapmf(x, %f, %f, %f, %f);\n', ...
                    fis.input(i).name, mf.name, mf.params(1), mf.params(2), mf.params(3), mf.params(4));
            elseif strcmp(mf.type, 'gaussmf')
                fprintf(fid, '        %s_%s = gaussmf(x, %f, %f);\n', ...
                    fis.input(i).name, mf.name, mf.params(1), mf.params(2));
            elseif strcmp(mf.type, 'gbellmf')
                fprintf(fid, '        %s_%s = gbellmf(x, %f, %f, %f);\n', ...
                    fis.input(i).name, mf.name, mf.params(1), mf.params(2), mf.params(3));
            end
            fprintf(fid, '    endfunction\n\n');
        end
    end
    
    % Write rules - FIXED VERSION
    fprintf(fid, '    // Rule evaluation\n');
    fprintf(fid, '    real rule_strength [%d];\n\n', length(fis.rule));
    
    fprintf(fid, '    always @(posedge clk) begin\n');
    for i = 1:length(fis.rule)
        rule = fis.rule(i);
        
        % Build rule condition - FIXED: Use cell array
        conditions = {};
        for j = 1:length(fis.input)
            if rule.antecedent(j) > 0
                mf_name = fis.input(j).mf(rule.antecedent(j)).name;
                conditions{end+1} = sprintf('%s_%s(%s)', fis.input(j).name, mf_name, fis.input(j).name);
            end
        end
        
        % Write rule comment
        fprintf(fid, '        // Rule %d: IF ', i);
        for k = 1:length(conditions)
            if k > 1
                fprintf(fid, ' AND ');
            end
            fprintf(fid, '%s', conditions{k});
        end
        fprintf(fid, ' THEN %s is %s\n', ...
            fis.output(1).name, fis.output(1).mf(rule.consequent).name);
        
        % Write rule strength calculation
        if length(conditions) == 1
            fprintf(fid, '        rule_strength[%d] = %s;\n', i-1, conditions{1});
        else
            fprintf(fid, '        rule_strength[%d] = min(''{', i-1);
            for k = 1:length(conditions)
                if k > 1
                    fprintf(fid, ', ');
                end
                fprintf(fid, '%s', conditions{k});
            end
            fprintf(fid, '});\n');
        end
    end
    
    % Defuzzification
    fprintf(fid, '\n        // Defuzzification - Center of Gravity\n');
    fprintf(fid, '        real numerator = 0.0;\n');
    fprintf(fid, '        real denominator = 0.0;\n');
    fprintf(fid, '        \n');
    
    for i = 1:length(fis.rule)
        rule = fis.rule(i);
        output_mf = fis.output(1).mf(rule.consequent);
        
        % Calculate centroid based on MF type
        if strcmp(output_mf.type, 'constant')
            centroid = output_mf.params(1);
        elseif strcmp(output_mf.type, 'trimf')
            centroid = mean(output_mf.params(1:3));
        elseif strcmp(output_mf.type, 'trapmf')
            centroid = mean(output_mf.params(1:4));
        elseif strcmp(output_mf.type, 'gaussmf')
            centroid = output_mf.params(2); % center
        elseif strcmp(output_mf.type, 'gbellmf')
            centroid = output_mf.params(3); % center
        else
            centroid = 0.0;
        end
        
        fprintf(fid, '        numerator = numerator + rule_strength[%d] * %f;\n', i-1, centroid);
        fprintf(fid, '        denominator = denominator + rule_strength[%d];\n', i-1);
    end
    
    fprintf(fid, '        \n');
    fprintf(fid, '        if (denominator > 1e-9) begin\n');
    fprintf(fid, '            %s = numerator / denominator;\n', fis.output(1).name);
    fprintf(fid, '        end else begin\n');
    fprintf(fid, '            %s = 0.0;\n', fis.output(1).name);
    fprintf(fid, '        end\n');
    
    fprintf(fid, '    end\n\n');
    
    % Helper functions
    fprintf(fid, '    // Membership function helpers\n');
    fprintf(fid, '    function real trimf;\n');
    fprintf(fid, '        input real x, a, b, c;\n');
    fprintf(fid, '        begin\n');
    fprintf(fid, '            if (x <= a || x >= c) trimf = 0.0;\n');
    fprintf(fid, '            else if (x <= b) trimf = (x - a) / (b - a);\n');
    fprintf(fid, '            else trimf = (c - x) / (c - b);\n');
    fprintf(fid, '        end\n');
    fprintf(fid, '    endfunction\n\n');
    
    fprintf(fid, '    function real trapmf;\n');
    fprintf(fid, '        input real x, a, b, c, d;\n');
    fprintf(fid, '        begin\n');
    fprintf(fid, '            if (x <= a || x >= d) trapmf = 0.0;\n');
    fprintf(fid, '            else if (x >= b && x <= c) trapmf = 1.0;\n');
    fprintf(fid, '            else if (x <= b) trapmf = (x - a) / (b - a);\n');
    fprintf(fid, '            else trapmf = (d - x) / (d - c);\n');
    fprintf(fid, '        end\n');
    fprintf(fid, '    endfunction\n\n');
    
    fprintf(fid, '    function real gaussmf;\n');
    fprintf(fid, '        input real x, sigma, c;\n');
    fprintf(fid, '        begin\n');
    fprintf(fid, '            gaussmf = exp(-((x - c) * (x - c)) / (2.0 * sigma * sigma));\n');
    fprintf(fid, '        end\n');
    fprintf(fid, '    endfunction\n\n');
    
    fprintf(fid, '    function real gbellmf;\n');
    fprintf(fid, '        input real x, a, b, c;\n');
    fprintf(fid, '        begin\n');
    fprintf(fid, '            gbellmf = 1.0 / (1.0 + pow(abs((x - c) / a), 2.0 * b));\n');
    fprintf(fid, '        end\n');
    fprintf(fid, '    endfunction\n\n');
    
    fprintf(fid, '    function real min;\n');
    fprintf(fid, '        input real vals[];\n');
    fprintf(fid, '        real result;\n');
    fprintf(fid, '        begin\n');
    fprintf(fid, '            result = vals[0];\n');
    fprintf(fid, '            for (int i = 1; i < vals.size(); i++) begin\n');
    fprintf(fid, '                if (vals[i] < result) result = vals[i];\n');
    fprintf(fid, '            end\n');
    fprintf(fid, '            min = result;\n');
    fprintf(fid, '        end\n');
    fprintf(fid, '    endfunction\n\n');
    
    fprintf(fid, 'endmodule\n');
    fclose(fid);
    
    fprintf('SystemVerilog code generated: %s\n', output_sv);
end